"""
Misaka Cipher - Code Generator
Template-based Python code generation for tools
"""

from typing import Dict, Any
from pathlib import Path

from .tool_spec import ToolSpec, ParameterSpec
from core.utils import get_logger

logger = get_logger(__name__)


class CodeGenerator:
    """
    Generates Python code from ToolSpec using templates.
    
    Supports function and class-based implementations.
    """
    
    def __init__(self):
        """Initialize Code Generator."""
        self.templates_dir = Path(__file__).parent / "templates"
        logger.info("Code Generator initialized")
    
    def generate(self, spec: ToolSpec) -> str:
        """
        Generate Python code from ToolSpec.
        
        Args:
            spec: Tool specification
            
        Returns:
            Generated Python code
        """
        if spec.implementation_type == "function":
            code = self._generate_function(spec)
        elif spec.implementation_type == "class":
            code = self._generate_class(spec)
        else:
            raise ValueError(f"Unknown implementation type: {spec.implementation_type}")
        
        logger.info(f"Generated code for: {spec.name} ({spec.implementation_type})")
        return code
    
    def _generate_function(self, spec: ToolSpec) -> str:
        """Generate function-based tool."""
        # Build parameter string
        params = self._build_param_string(spec.parameters)
        
        # Build docstring
        docstring = self._build_docstring(spec)
        
        # Build imports
        imports = self._build_imports(spec.imports)
        
        # Build implementation (MUST be real code from Nexus)
        implementation = spec.implementation_hints.get('code')
        
        if not implementation or implementation.strip() == '':
            raise ValueError(f"No implementation code provided for {spec.name}. Tool generation requires real code from Nexus.")
        
        # Generate code
        code = f'''{imports}

def {spec.name}({params}):
    """
{docstring}
    """
{self._indent(implementation, 4)}
'''
        
        return code
    
    def _generate_class(self, spec: ToolSpec) -> str:
        """Generate class-based tool."""
        # Build parameter string for __init__
        params = self._build_param_string(spec.parameters)
        
        # Build docstring
        docstring = self._build_docstring(spec)
        
        # Build imports
        imports = self._build_imports(spec.imports)
        
        # Build implementation (MUST be real code from Nexus)
        implementation = spec.implementation_hints.get('code')
        
        if not implementation or implementation.strip() == '':
            raise ValueError(f"No implementation code provided for {spec.name}. Tool generation requires real code from Nexus.")
        
        # Generate code
        code = f'''{imports}

class {spec.name}:
    """
{docstring}
    """
    
    def __init__(self, {params}):
        """Initialize {spec.name}."""
{self._indent(self._build_init_body(spec.parameters), 8)}
    
    def execute(self):
        """Execute the tool operation."""
{self._indent(implementation, 8)}
'''
        
        return code
    
    def _build_param_string(self, parameters: list[ParameterSpec]) -> str:
        """Build parameter string for function/method signature."""
        if not parameters:
            return ""
        
        param_strs = []
        for param in parameters:
            if param.required:
                param_strs.append(f"{param.name}: {param.type}")
            else:
                default = repr(param.default) if param.default is not None else "None"
                param_strs.append(f"{param.name}: {param.type} = {default}")
        
        return ", ".join(param_strs)
    
    def _build_docstring(self, spec: ToolSpec) -> str:
        """Build function/class docstring."""
        doc_lines = [
            f"    {spec.description}",
            "",
            f"    Generated by The Forge",
            f"    Trace ID: {spec.trace_id or 'N/A'}",
        ]
        
        if spec.parameters:
            doc_lines.append("")
            doc_lines.append("    Args:")
            for param in spec.parameters:
                doc_lines.append(f"        {param.name}: {param.description}")
        
        if spec.return_type != "Any":
            doc_lines.append("")
            doc_lines.append("    Returns:")
            doc_lines.append(f"        {spec.return_type}")
        
        return "\n".join(doc_lines)
    
    def _build_imports(self, imports: list[str]) -> str:
        """Build import statements."""
        if not imports:
            return "# No imports required"
        
        import_lines = []
        for imp in imports:
            if " from " in imp or imp.startswith("from "):
                import_lines.append(imp)
            else:
                import_lines.append(f"import {imp}")
        
        return "\n".join(import_lines)
    
    def _build_init_body(self, parameters: list[ParameterSpec]) -> str:
        """Build __init__ method body for class."""
        if not parameters:
            return "pass"
        
        lines = []
        for param in parameters:
            lines.append(f"self.{param.name} = {param.name}")
        
        return "\n".join(lines)
    
    def _generate_placeholder_impl(self, spec: ToolSpec) -> str:
        """Generate placeholder implementation."""
        lines = [
            "# TODO: Implement tool logic",
            f"# This is a placeholder for {spec.name}",
            "",
        ]
        
        if spec.parameters:
            lines.append("# Available parameters:")
            for param in spec.parameters:
                lines.append(f"#   - {param.name}: {param.type}")
            lines.append("")
        
        if spec.return_type != "Any":
            lines.append(f"# Should return: {spec.return_type}")
            if spec.return_type == "dict":
                lines.append("return {}")
            elif spec.return_type == "list":
                lines.append("return []")
            elif spec.return_type == "str":
                lines.append('return ""')
            elif spec.return_type == "int":
                lines.append("return 0")
            elif spec.return_type == "bool":
                lines.append("return True")
            else:
                lines.append("return None")
        else:
            lines.append("return None")
        
        return "\n".join(lines)
    
    def _indent(self, text: str, spaces: int) -> str:
        """Indent text by specified number of spaces."""
        indent = " " * spaces
        return "\n".join(indent + line if line.strip() else "" for line in text.split("\n"))
